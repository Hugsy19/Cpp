# 构造/析构/赋值运算

## 了解C++会自动生成并调用的函数

- 类中没有自定义相关函数下，编译器会自动创建默认构造函数、拷贝/移动构造函数、拷贝/移动赋值运算符及析构函数。
- 合成的拷贝构造函数和赋值运算符，只会单纯地将来源对象的每一个non-static成员变量拷贝到目标对象。
  - 对内含引用、`const`成员的类，编译器会拒绝合成赋值运算符。

## 不使用编译器合成的函数时需明确拒绝

- C++11以前一般采用将拷贝、赋值运算符声明为`private`并不予实现的方式来阻止拷贝。
- C++11后则可以通过在参数列表后加`=delete`，将拷贝、赋值运算定义为删除的函数。

## 为多态基类声明虚析构函数

-  多态（polymorphic）基类中的析构函数应该加上`virtual`以声明为虚函数。
-  当类中带有虚函数时，该类也应该拥有虚析构函数。
-  不作为基类或不具备多态性的类不应该声明虚析构函数。

## 不让异常逃离析构函数

- 析构函数中绝对不能抛出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应当捕获该异常且终止程序或不再传播该异常。
- 如客户需对某操作函数运行时抛出的异常进行处理，应该为客户提供普通函数来执行该操作。

## 构造或析构过程中不调用虚函数

- 构造和析构函数中不要调用虚函数，因为这类调用无法下降到派生类之中。

## 赋值运算符应返回左侧运算对象的引用

- 为了类似`x = y = z = 1`的连续赋值，赋值运算符必须定义为成员函数，且返回左侧对象的引用即**reference to *this**。
- 该条同样适用于`+=`等复合赋值运算符。

## 赋值运算符应处理自赋值的情况

- 赋值运算符通常组合了析构函数和构造函数的操作，需要能够处理**自赋值**的情况，且应该是**异常安全**的。
  - 下面的例子只处理了自赋值问题，但如果`new Bitmap`抛出异常将产生不完整的对象：
  ```cpp
  Widget& Widget::operator=(const Widget& rhs)
  {
    if (this == &rhs) return *this;

    delete pb;
    pb = new Bitmap(*rhs.pb);
    return *this;
  }
  ```
  - 适当调整语句顺序，即可在处理自赋值的同时保证异常安全：
  ```cpp
  Widget& Widget::operator=(const Widget& rhs)
  {
    Bitmap *pOrig = pb;
    pb = new Bitmap(*rhs.pb);
    delete pOrig;
    return *this;
  }
  ```
  - 更好的一种方法是先定义`swap`函数，然后用**拷贝并交换**（copy and swap）技术来实现赋值运算符：
  ```cpp
  Widget& Widget::operator=(const Widget& rhs)
  {
    swap(rhs);
    return *this;
  }
  ```

## 复制对象时切勿遗漏其成员

